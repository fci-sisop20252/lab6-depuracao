\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{tabularx,booktabs}
\usepackage{float}
\usepackage{emoji}

\usepackage{tikz}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{geometry}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage{mdframed}

% Margens mais estreitas
\geometry{
    top=2cm,
    bottom=2cm,
    left=2cm,
    right=2cm,
    includehead,
    includefoot
}

% Cores
\definecolor{mackblue}{RGB}{0,73,144}
\definecolor{lightblue}{RGB}{230,240,255}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}
\definecolor{outputback}{rgb}{0.95,1.0,0.95}

% Configuração para código (sem números de linha)
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle, language=C}

% Cabeçalhos e rodapés
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Sistemas Operacionais - Prof. Lucas Figueiredo}
\fancyhead[R]{Depuração e Análise de Vazamento de Memória}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

% Estilo para títulos
\usepackage{titlesec}
\titleformat{\section}
{\normalfont\Large\bfseries\color{mackblue}}
{\thesection}{1em}{}[\titlerule]

\titleformat{\subsection}
{\normalfont\large\bfseries\color{mackblue}}
{\thesubsection}{1em}{}

% Configuração do texto
\setlength{\parindent}{0cm}
\setlength{\parskip}{0.4cm}

% Estilo para saídas de código
\mdfdefinestyle{outputstyle}{
    backgroundcolor=outputback,
    linecolor=black,
    linewidth=0.5pt,
    frametitlerule=true,
    frametitlebackgroundcolor=white,
    innertopmargin=5pt,
    innerbottommargin=5pt,
    innerleftmargin=5pt,
    innerrightmargin=5pt,
}

\title{%
    \vspace{-1.5cm}
    \begin{center}
    \end{center}
    \vspace{0.5cm}
    {\LARGE\bfseries UNIVERSIDADE PRESBITERIANA MACKENZIE}\\
    {\large Faculdade de Computação e Informática}\\
    \vspace{1.0cm}
    {\Huge\bfseries\color{mackblue} Laboratório: Ferramentas de Depuração e Análise de Vazamento de Memória}\\
    \vspace{0.5cm}
    {\LARGE\bfseries Material de Estudo e Exercícios}\\
    \vspace{0.3cm}
    {\large\itshape Disciplina: Sistemas Operacionais}
}

\author{{\large Prof. Lucas Cerqueira Figueiredo}}
\date{{\large 2º Semestre de 2025}}

\begin{document}

\maketitle
\thispagestyle{empty}

\tableofcontents
\newpage

\section{Introdução}

A depuração de problemas de memória é uma habilidade bem relevante para programadores, especialmente em linguagens como C, onde o gerenciamento de memória é realizado manualmente. Nesse laboratório vocês vão explorar o uso do Valgrind, uma ferramenta para detecção de problemas de memória em programas C/C++.

No contexto de Sistemas Operacionais, o gerenciar memória corretamente é crítico, pois o próprio kernel do sistema deve implementar mecanismos de alocação, rastreamento e liberação de recursos de memória para os processos. Um vazamento de memória no kernel pode comprometer todo o sistema, enquanto acessos inválidos podem causar falhas de segmentação (segmentation fault) e comprometer a estabilidade do sistema.

\section{Fundamentos da Depuração de Memória}

\subsection{Problemas Comuns de Memória}

\begin{enumerate}
    \item \textbf{Vazamento de Memória (Memory Leak)}: 
    \begin{itemize}
        \item Ocorre quando alocamos memória dinamicamente, mas esquecemos de liberá-la
        \item Causa esgotamento gradual da memória disponível
        \item Em sistemas operacionais, pode levar a falhas por falta de recursos
    \end{itemize}

    \item \textbf{Acesso Inválido (Invalid Access)}:
    \begin{itemize}
        \item Ler/escrever em posições de memória fora dos limites alocados
        \item Acessar memória já liberada (use-after-free)
        \item No contexto de SOs, pode levar a corrupção de dados críticos do sistema
    \end{itemize}

    \item \textbf{Liberação Dupla (Double Free)}:
    \begin{itemize}
        \item Tentar liberar a mesma região de memória mais de uma vez
        \item Pode corromper as estruturas internas do gerenciador de memória
    \end{itemize}

    \item \textbf{Uso de Variáveis Não Inicializadas}:
    \begin{itemize}
        \item Utilizar o valor de variáveis sem inicialização prévia
        \item Pode levar a comportamentos imprevisíveis e difíceis de rastrear
    \end{itemize}
\end{enumerate}

\begin{tcolorbox}[colback=lightblue!20, colframe=mackblue, title=\emoji{light-bulb} Relação com Sistemas Operacionais]
Os problemas de memória são particularmente relevantes para o contexto de SO:
\begin{itemize}
    \item O kernel precisa gerenciar a memória para todos os processos
    \item Vazamentos de memória no espaço do kernel não são automaticamente corrigidos quando um processo termina
    \item A memória do kernel é limitada e compartilhada por todo o sistema
    \item Falhas de memória no kernel podem comprometer a estabilidade de todo o sistema
\end{itemize}
\end{tcolorbox}

\section{Valgrind: Ferramenta de Análise Dinâmica}

O Valgrind é um framework para ferramentas de análise dinâmica de código, sendo Memcheck seu componente mais utilizado para detecção de problemas de memória. Essa ferramenta foi criada para ajudar desenvolvedores a encontrar e corrigir problemas relacionados à memória que são difíceis de detectar com métodos tradicionais de depuração.

\subsection{Como o Valgrind Funciona}

\begin{enumerate}
    \item Executa o programa em um ambiente controlado
    \item Monitora todas as operações de memória (alocações, liberações, acessos)
    \item Detecta problemas em tempo de execução
    \item Gera relatórios detalhados sobre os problemas encontrados
\end{enumerate}

\subsection{Uso Básico do Valgrind}

Para utilizar o Valgrind, você precisa:

\begin{enumerate}
    \item Compilar o programa com flags de depuração:
    \begin{lstlisting}
    gcc -g programa.c -o programa
    \end{lstlisting}
    
    \item Executar com Valgrind:
    \begin{lstlisting}
    valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./programa
    \end{lstlisting}
\end{enumerate}

Principais opções:
\begin{itemize}
    \item \texttt{--leak-check=full}: Detalhamento completo dos vazamentos
    \item \texttt{--show-leak-kinds=all}: Mostra todos os tipos de vazamento
    \item \texttt{--track-origins=yes}: Rastreia a origem de valores não inicializados
\end{itemize}

\subsection{Interpretando a Saída do Valgrind}

O relatório do Valgrind possui seções importantes:

\begin{enumerate}
    \item \textbf{Erros de memória} - Operações inválidas durante a execução
    \item \textbf{Resumo de heap} - Estatísticas sobre alocação/liberação 
    \item \textbf{Vazamentos de memória} - Detalhes sobre memória não liberada
\end{enumerate}

Tipos de vazamento reportados:
\begin{itemize}
    \item \textbf{Definitivamente perdido}: Memória não liberada e sem referência
    \item \textbf{Indiretamente perdido}: Perdido devido a outro vazamento
    \item \textbf{Possivelmente perdido}: Valgrind não tem certeza se há referência
    \item \textbf{Ainda acessível}: Memória não liberada, mas ainda referenciada
\end{itemize}

\begin{tcolorbox}[colback=lightblue!20, colframe=mackblue, title=Exemplo de Saída do Valgrind]
\begin{verbatim}
==12345== HEAP SUMMARY:
==12345==     in use at exit: 40 bytes in 1 blocks
==12345==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==12345== 
==12345== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/...)
==12345==    by 0x400584: funcao_com_vazamento (leak.c:5)
==12345==    by 0x4005A5: main (leak.c:14)
\end{verbatim}
\end{tcolorbox}


\section{Exercícios Práticos}

\subsection{Exercício 1: Identificação de Vazamento de Memória}

\textbf{Código com problema}:

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

void funcao_com_vazamento() {
    int *array = (int*) malloc(10 * sizeof(int));
    
    for (int i = 0; i < 10; i++) {
        array[i] = i * 10;
    }
    
    // Esqueceu de liberar a memória!
}

int main() {
    for (int i = 0; i < 5; i++) {
        funcao_com_vazamento();
    }
    printf("Programa executado com sucesso!\n");
    return 0;
}
\end{lstlisting}

\textbf{Tarefas}:
\begin{enumerate}
    \item Compile o programa com flags de depuração
    \item Execute-o com Valgrind e analise o relatório
    \item Identifique quantos bytes foram vazados e em quantos blocos
    \item Corrija o problema de vazamento
\end{enumerate}

\textbf{Contexto de SO}: Este tipo de vazamento é similar ao que pode ocorrer em um sistema operacional quando um driver de dispositivo aloca memória para operações de E/S mas não a libera corretamente, levando a degradação gradual do desempenho do sistema.

\subsection{Exercício 2: Uso de Memória Não Inicializada}

\textbf{Código com problema}:

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *array = (int*) malloc(10 * sizeof(int));
    int soma = 0;
    
    // Não inicializamos o array!
    
    // Tentamos usar os valores não inicializados
    for (int i = 0; i < 10; i++) {
        soma += array[i];
    }
    
    printf("A soma dos elementos é: %d\n", soma);
    
    free(array);
    return 0;
}
\end{lstlisting}

\textbf{Tarefas}:
\begin{enumerate}
    \item Compile e execute com Valgrind
    \item Identifique o problema reportado
    \item Corrija o código para eliminar o erro
\end{enumerate}

\textbf{Contexto de SO}: Em sistemas operacionais, usar memória não inicializada pode revelar dados de outros processos (violação de segurança) ou levar a comportamentos imprevisíveis. É por isso que sistemas modernos como Linux, ao alocar memória para um novo processo, geralmente a preenche com zeros ou valores aleatórios por questões de segurança.

\subsection{Exercício 3: Acesso Fora dos Limites (Buffer Overflow)}

\textbf{Código com problema}:

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *array = (int*) malloc(5 * sizeof(int));
    
    for (int i = 0; i < 5; i++) {
        array[i] = i;
    }
    
    // Acesso fora dos limites!
    for (int i = 0; i <= 5; i++) {
        printf("array[%d] = %d\n", i, array[i]);
    }
    
    free(array);
    return 0;
}
\end{lstlisting}

\textbf{Tarefas}:
\begin{enumerate}
    \item Execute com Valgrind e analise o relatório
    \item Identifique o problema de acesso à memória
    \item Corrija o código
\end{enumerate}

\textbf{Contexto de SO}: Os buffer overflows são uma das vulnerabilidades mais comuns em sistemas operacionais e aplicações. Eles podem levar a corrupção de dados, crashes do sistema e até exploração por software malicioso. Muitos ataques históricos a sistemas operacionais exploraram esse tipo de vulnerabilidade.

\subsection{Exercício 4: Liberação Dupla (Double Free)}

\textbf{Código com problema}:

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *ptr = (int*) malloc(sizeof(int));
    *ptr = 42;
    
    printf("Valor: %d\n", *ptr);
    
    free(ptr);
    printf("Memória liberada uma vez\n");
    
    // Tentativa de liberar novamente!
    free(ptr);
    printf("Tentativa de liberar memória novamente\n");
    
    return 0;
}
\end{lstlisting}

\textbf{Tarefas}:
\begin{enumerate}
    \item Execute com Valgrind
    \item Identifique o erro de liberação dupla
    \item Corrija o código para evitar o problema
\end{enumerate}

\textbf{Contexto de SO}: Liberações duplas podem corromper as estruturas de dados internas do gerenciador de memória do sistema operacional. Se isso ocorrer no kernel, pode levar a falhas catastróficas no sistema. Muitos gerenciadores de memória modernos implementam proteções contra liberações duplas.

\subsection{Exercício 5: Uso Após Liberação (Use-After-Free)}

\textbf{Código com problema}:

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

int main() {
    int *ptr = (int*) malloc(sizeof(int));
    *ptr = 42;
    
    printf("Valor inicial: %d\n", *ptr);
    
    free(ptr);
    
    // Uso após liberação!
    *ptr = 100;
    printf("Valor após liberação: %d\n", *ptr);
    
    return 0;
}
\end{lstlisting}

\textbf{Tarefas}:
\begin{enumerate}
    \item Execute com Valgrind
    \item Identifique o problema de uso após liberação
    \item Corrija o código
\end{enumerate}

\textbf{Contexto de SO}: Vulnerabilidades do tipo use-after-free são comuns em drivers de dispositivos e no próprio kernel dos sistemas operacionais. Quando a memória é liberada, ela pode ser realocada para outro propósito, mas se o código original continuar a usá-la, pode interferir com o novo uso, causando comportamentos imprevisíveis.

\subsection{Exercício 6: Implementação de Lista Ligada com Gerenciamento de Memória}

Implemente uma função de gerenciamento simplificado de memória para uma lista ligada:

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

typedef struct Node {
    int value;
    struct Node* next;
} Node;

// Função para criar um novo nó
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("Erro: falha na alocação de memória\n");
        exit(1);
    }
    newNode->value = value;
    newNode->next = NULL;
    return newNode;
}

// Função para adicionar um nó no final da lista
void appendNode(Node** head, int value) {
    Node* newNode = createNode(value);
    
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    
    Node* current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    
    current->next = newNode;
}

// Função para imprimir a lista
void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->value);
        current = current->next;
    }
    printf("NULL\n");
}

// TODO: Implemente a função para liberar toda a lista
void freeList(Node* head) {
    // Sua implementação aqui
}

int main() {
    Node* list = NULL;
    
    // Adiciona 10 nós
    for (int i = 0; i < 10; i++) {
        appendNode(&list, i * 10);
    }
    
    printList(list);
    
    // TODO: Libere a memória da lista
    
    return 0;
}
\end{lstlisting}

\textbf{Tarefas}:
\begin{enumerate}
    \item Implemente a função \texttt{freeList} para liberar corretamente toda a memória da lista
    \item Utilizando Valgrind, verifique se sua implementação está livre de vazamentos
    \item Teste sua solução com diferentes tamanhos de lista
\end{enumerate}

\textbf{Contexto de SO}: Listas ligadas são estruturas de dados fundamentais em sistemas operacionais, usadas para implementar tabelas de processos, gerenciamento de memória e filas de E/S. O gerenciamento correto destas estruturas é crucial para a estabilidade do sistema.

\section{Dicas e Melhores Práticas}

\begin{enumerate}
    \item \textbf{Sempre inicialize variáveis} antes de usá-las
    \item \textbf{Para cada malloc(), deve haver um free()} correspondente
    \item \textbf{Verifique o retorno de malloc()} para garantir que a alocação foi bem-sucedida
    \item \textbf{Use NULL após liberar um ponteiro} para evitar uso acidental após liberação:
    \begin{lstlisting}
    free(ptr);
    ptr = NULL;
    \end{lstlisting}
    \item \textbf{Verifique os limites de arrays} antes de acessá-los
    \item \textbf{Compile com flags de depuração} (-g) para obter relatórios mais detalhados
\end{enumerate}

\section{Entrega via GitHub}

\textbf{IMPORTANTE}: A entrega deste laboratório é feita exclusivamente via GitHub. Utilize o GitHub Codespaces para realizar os exercícios, eliminando a necessidade de configuração local do ambiente.

Para cada exercício, você deve incluir no repositório:
\begin{enumerate}
    \item \texttt{original.c} - Código fornecido com o problema
    \item \texttt{corrigido.c} - Sua solução corrigida
    \item \texttt{valgrind\_original.txt} - Saída completa do Valgrind para o código original
    \item \texttt{valgrind\_corrigido.txt} - Saída completa do Valgrind para o código corrigido
\end{enumerate}

\begin{tcolorbox}[colback=lightblue!20, colframe=mackblue, title=\emoji{light-bulb} Estrutura do Repositório]
Os exercícios estão organizados na seguinte estrutura:
\begin{verbatim}
lab6-depuracao/
├── exercicios/
│   ├── ex1_memory_leak/
│   │   ├── original.c
│   │   ├── corrigido.c
│   │   ├── valgrind_original.txt
│   │   └── valgrind_corrigido.txt
│   ├── ex2_uninitialized/
│   │   └── ...
│   └── ex6_linked_list/
│       └── ...
\end{verbatim}

Complete os exercícios, faça commits incrementais e push para o GitHub.
Consulte o README.md para instruções detalhadas do workflow.
\end{tcolorbox}

\subsection{Usando o GitHub Codespaces}

O GitHub Codespaces fornece um ambiente de desenvolvimento completo na nuvem, com todas as ferramentas necessárias (gcc, Valgrind) já instaladas:

\begin{enumerate}
    \item Acesse seu repositório no GitHub
    \item Clique em \textbf{Code} > \textbf{Codespaces} > \textbf{Create codespace on main}
    \item Aguarde a inicialização do ambiente
    \item Use o terminal integrado para compilar e executar os programas
    \item Faça commits e push diretamente do Codespaces
\end{enumerate}

Não é necessário instalar nada localmente!

\section{Bibliografia Recomendada}

\begin{itemize}
    \item Documentação oficial do Valgrind: \url{http://valgrind.org/}
    \item TANENBAUM, A. S. \textit{Sistemas Operacionais Modernos}. 3ª ed. São Paulo: Pearson, 2010.
    \item SILBERSCHATZ, A., GALVIN, P.B, GAGNE, G. \textit{Fundamentos de Sistemas Operacionais}. 8ª. ed. São Paulo: LTC, 2010.
    \item ARPACI-DUSSEAU, R. H.; ARPACI-DUSSEAU, A. C. \textit{Operating Systems: Three Easy Pieces}. Arpaci-Dusseau Books, versão 1.10, novembro de 2023.
\end{itemize}

\end{document}
